<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to xjc&#39;s blog</title>
  
  
  <link href="https://nuclearslippers.github.io/atom.xml" rel="self"/>
  
  <link href="https://nuclearslippers.github.io/"/>
  <updated>2025-03-31T08:30:16.000Z</updated>
  <id>https://nuclearslippers.github.io/</id>
  
  <author>
    <name>XJC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://nuclearslippers.github.io/onnx/"/>
    <id>https://nuclearslippers.github.io/onnx/</id>
    <published>2025-04-06T08:50:57.985Z</published>
    <updated>2025-03-31T08:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录onnx的相关知识</p><h2 id="center-onnx介绍"><center> onnx介绍</h2><p>开放神经网络交换 ONNX（Open Neural Network Exchange）是一套表示深度神经网络模型的开放格式，由微软和 Facebook 于 2017 推出。</p><p>通俗的说，onnx就是不同模型的中间桥梁。pytorch、tensorflow、mxnet等模型都可以转换为onnx模型，然后onnx模型可以转换为其他模型，例如TensorRT等。</p><h2 id="center-从部署流程上认识onnx"><center> 从部署流程上认识onnx</h2><p>下面是一个常规的神经网络部署流程：</p><ol><li>前期准备<br>根据任务问题，我们选择解决的方案，分类、检测、分割等。然后选择合适的模型，例如yolov3、faster rcnn。</li><li>模型训练<br>使用pytorch、tensorflow等框架训练模型，训练完成后，保存模型。<br>例如训练YOLO模型，我们得到的结果是一个.pt文件</li><li>转换模型<br>将训练好的模型转换为onnx模型，方便后续部署。<br>onnx可以理解为封装成了一个包，输入输出都是tensor。</li><li>具体部署<br>将onnx模型部署到具体的硬件上，例如NVIDIA的tensorrt、高通的SNPE等。</li></ol><h2 id="center-onnx具体部署"><center> onnx具体部署</h2><p>下面我们以pytorch模型YOLOv8为例，介绍onnx的部署流程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将pytorch的模型转换为onnx模型</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">model = YOLO(<span class="string">&quot;yolov8s.pt&quot;</span>) <span class="comment"># 加载模型</span></span><br><span class="line">output_path = <span class="string">&quot;/PATH/TO/OUTPUT/&quot;</span> <span class="comment"># 定义输出路径</span></span><br><span class="line">input_tensor = np.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">640</span>, <span class="number">640</span>) <span class="comment"># 定义输入tensor的形状</span></span><br><span class="line"></span><br><span class="line">torch.onnx.export(model,</span><br><span class="line">                input_tensor,</span><br><span class="line">                output_path,</span><br><span class="line">                opset_version=<span class="number">12</span>, <span class="comment"># 指定onnx的版本，主要在于一些算子是否支持</span></span><br><span class="line">                input_names=[<span class="string">&quot;images&quot;</span>], <span class="comment"># 输入tensor的名称</span></span><br><span class="line">                output_names=[<span class="string">&quot;output&quot;</span>], <span class="comment"># 输出tensor的名称</span></span><br><span class="line">                )</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调用onnxruntime进行推理</span></span><br><span class="line"><span class="keyword">import</span> onnxruntime <span class="keyword">as</span> ort</span><br><span class="line"></span><br><span class="line"><span class="comment"># onnx inference</span></span><br><span class="line">onnx_model_path = <span class="string">&#x27;/PATH/TO/ONNX_MODEL/&#x27;</span></span><br><span class="line">session = ort.InferenceSession(onnx_model_path)</span><br><span class="line">input_name = session.get_inputs()[<span class="number">0</span>].name</span><br><span class="line">output_name = session.get_outputs()[<span class="number">0</span>].name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输入数据转换为onnx网络的输入格式，并且要求是numpy数组</span></span><br><span class="line">onnx_input = np.random.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">640</span>, <span class="number">640</span>) </span><br><span class="line"></span><br><span class="line">result = session.run([output_name], &#123;input_name: onnx_input&#125;)</span><br></pre></td></tr></table></figure><p>接下来我们具体举例部署mmaction2中的posec3d模型。<br>mmlab的封装非常严实，因此如果没有官方的部署代码，我们很难直接导出onnx。<br>首先我们要明确两个东西，输入输出是什么，它的形状是什么的。<br>这里的输入输出要严格落实到pytorch模型，像mmlab这种进行严格封装的模型，需要进行层层摸索。</p><p>例如posec3d的输入是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.randn(batch, num_joints, num_frames, image_size, image_size)</span><br><span class="line">torch.randn(<span class="number">2</span>, <span class="number">17</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure><p>输出是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.randn(batch, num_classes)</span><br><span class="line">torch.randn(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>上述格式就是通过mmlab给的&quot;.\tools\deployment\export_onnx_posec3d.py&quot;得到的onnx模型。<br>要符合onnx的输入输出格式，我们就要将输入输出格式进行转换。</p><p>输入的调整直接调用&quot;inference_skeleton&quot;函数，稍微微调即可。输出需要额外调整。</p><p>首先是对batch的理解，batch是2<em>num_clips。<br>就是对输入的一段视频X帧，均匀取num_clips个片段，每个片段长度为clip_length。（这些片段是可以重叠的）<br>2</em>num_clips是将骨骼信息转换时encoder造成的。</p><p>模型会按照batch来进行推理，因此对于输出我们需要进行平均。<br><a href="https://github.com/open-mmlab/mmaction2/issues/2641">github issue</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要记录onnx的相关知识&lt;/p&gt;
&lt;h2 id=&quot;center-onnx介绍&quot;&gt;&lt;center&gt; onnx介绍&lt;/h2&gt;
&lt;p&gt;开放神经网络交换 ONNX（Open Neural Network Exchange）是一套表示深度神经网络模型的开放格式，由微软和 Fac</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mmlab学习笔记</title>
    <link href="https://nuclearslippers.github.io/mmlab/"/>
    <id>https://nuclearslippers.github.io/mmlab/</id>
    <published>2025-03-16T07:21:20.000Z</published>
    <updated>2025-04-06T08:50:47.979Z</updated>
    
    <content type="html"><![CDATA[<p>本文大致介绍mmlab的基本框架。</p><h2 id="center-基本知识"><center> 基本知识</h2><ol><li>config 文件<br>（1）<a href="https://mmdetection.readthedocs.io/zh-cn/latest/user_guides/config.html#id13">命名规则</a></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;algorithm name&#125;_&#123;model component names [component1]_[component2]_[...]&#125;_&#123;training settings&#125;_&#123;training dataset information&#125;_&#123;testing dataset information&#125;.py</span><br></pre></td></tr></table></figure><ul><li>algorithm name: 算法名称。<br>例如：faster_rcnn</li><li>model component names: 模型组件名称，包括backbone和neck等。<br>例如 r50-caffe_fpn_gn-head 表示在算法中使用 caffe 版本的 ResNet50、FPN 和 使用了 Group Norm 的检测头。</li><li>training settings: 训练设置， batch 大小、数据增强、损失、参数调度方式和训练最大轮次/迭代。<br>例如4xb4-mixup-giou-coslr-100e 表示使用 8 个 gpu 每个 gpu 4 张图、mixup 数据增强、GIoU loss、余弦退火学习率，并训练 100 个 epoch。</li><li>training dataset information: 训练数据集信息，例如：coco_2017_train</li><li>testing dataset information: 测试数据集信息，可选。例如：coco_2017_val</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文大致介绍mmlab的基本框架。&lt;/p&gt;
&lt;h2 id=&quot;center-基本知识&quot;&gt;&lt;center&gt; 基本知识&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;config 文件&lt;br&gt;
（1）&lt;a href=&quot;https://mmdetection.readthedocs.io/zh-cn</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>一些学习思路</title>
    <link href="https://nuclearslippers.github.io/paper/"/>
    <id>https://nuclearslippers.github.io/paper/</id>
    <published>2025-03-11T12:50:06.000Z</published>
    <updated>2025-03-15T02:36:40.078Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面，该文目的性很强，主要针对毕业任务，而非钻研科研，不过融汇百家思想的精华总是好多。非常感谢B站上的资料，让自己收益匪浅。之前总觉得一片茫然，听了之后还算是有了一定的目标和方向。<a href="https://www.bilibili.com/video/BV1Dg4y1m7F5?spm_id_from=333.788.videopod.episodes&amp;vd_source=07739525bb0db436069e43c124976911&amp;p=2">科研思路</a></p><h2 id="center-我要做什么？"><center> 我要做什么？</h2><p>这个问题一直困扰着我很久，总觉得这种方法会被淘汰，那种方法又有缺陷。自己的工作就缓慢推动。<br>那么不妨从另一个角度思考。首先，我们是要做AI相关，甚至可以说就是MOT方面的。人工智能方法最最重要的东西就是数据，因此问题来了，你有什么数据？<br>回答：没有自己的数据，只能用公开数据集。目前来说就是KITTI用的比较多了，Nusences还需要进一步学习，Waymo更是遥不可及。</p><ol><li>公开数据集<br>要做公开数据集，有利有弊。难度大，出文章难，但是一旦出文章大概率是好文章。</li><li>自己的数据集<br>如果组内已经有数据集了，那么毕业论文就问题不大了。</li><li>搜集数据集，自己标注<br>如果此时没有明确的研究方向，而且只想水毕业。可以这样做，找越偏越好的方向（检测，分割最水），圆一个好一点的理由。<br>但是对于这一方向，我还有自己的一些看法。自己其实可以录一个数据集，而且有一定的价值：基于BEV的无人机追踪数据集。<br>总结：当下自己要做的还是针对公开数据集KITTI做相关工作，后续可以补充Nusences</li></ol><h2 id="center-创新点从哪来-非正确科研"><center> 创新点从哪来（非正确科研）</h2><p>从简单来说，首先不要动大框架。因为需要自己手动实现，工作量很大。但是我有这个想法要做，因此需要多学习openmmlab的使用。<br>其次，加模块和改模块是最简单的。这里注意说提出新的模块，画好图（复杂，美观）即可。</p><h2 id="center-怎么做实验"><center> 怎么做实验</h2><ol><li><p>找基础模型<br>（1） 跑模型的原代码，一定要看效果怎么样<br>（2） debug理解源码<br>（3） 找相关领域的一些论文<br>（4） 把别人的模块拿过来用一下<br>（5） 没有源码=这个论文没用</p></li><li><p>消融实验（验证小模块）<br>（1）不一定都有效的<br>（2）尽可能找离谱的模块<br>（3）如果只有小模块，尽量有3-4个</p></li><li><p>对比实验<br>对比比自己差的就行</p></li></ol><h2 id="center-工具"><center> 工具</h2><p>CV：openmmlab<br>NLP: huggingface</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写在前面，该文目的性很强，主要针对毕业任务，而非钻研科研，不过融汇百家思想的精华总是好多。非常感谢B站上的资料，让自己收益匪浅。之前总觉得一片茫然，听了之后还算是有了一定的目标和方向。&lt;a href=&quot;https://www.bilibili.com/video/BV1Dg</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>mamba模块的简单原理</title>
    <link href="https://nuclearslippers.github.io/mamba/"/>
    <id>https://nuclearslippers.github.io/mamba/</id>
    <published>2025-03-09T08:28:19.000Z</published>
    <updated>2025-03-15T02:36:57.394Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录Mamba模型的学习。<a href="https://blog.csdn.net/weixin_44162361/article/details/144591024">参考资料</a></p><h2 id="center-提出的目的"><center> 提出的目的</h2><p>新的模型的出现，必然是为了解决过去模型的不足。</p><ol><li>Transformer在预测工作时，需要计算之前所有tokens的自注意力矩阵，这个工作的计算量时相当大的。也就是说预测时速度很慢，但是由于Transformer可以并行计算，所以训练非常快。</li><li>RNN 推理快，但是训练慢（不能并行计算），而且记忆时间不长。<br>那么我们就想有一种模型，训练也快推理也快。还有一定的记忆时长。</li></ol><h2 id="center-由简入深"><center> 由简入深</h2><ol><li><p>状态空间模型</p></li><li><p>离散化：零阶保持器</p></li><li><p>循环表示<br>循环表示用来推理</p></li><li><p>卷积表示<br>卷积表示用来训练</p></li><li><p>结构化状态空间模型(S4)<br>引入HiPPO（Hungering Hungry Hippo），用来使得A保持大容量记忆。</p></li><li><p>其它改进<br>有选择地保留信息(Selectively Retain Information)<br>扫描操作(The Scan Operation)<br>硬件感知算法(Hardware-aware Algorithm)</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文记录Mamba模型的学习。&lt;a href=&quot;https://blog.csdn.net/weixin_44162361/article/details/144591024&quot;&gt;参考资料&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;center-提出的目的&quot;&gt;&lt;center&gt; 提出的目</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>雷达相机的标定</title>
    <link href="https://nuclearslippers.github.io/calib/"/>
    <id>https://nuclearslippers.github.io/calib/</id>
    <published>2025-03-09T06:56:44.000Z</published>
    <updated>2025-03-09T06:58:50.613Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录使用opencalib来标定相机和激光雷达。在一般的多传感器融合方案中，激光雷达投影到相机的思路是应用最广泛的。</p><h2 id="center-opencalib"><center> Opencalib</h2><p><a href="https://github.com/PJLab-ADG/SensorsCalibration">github链接</a><br>该仓库集合了各种传感器标定的实现方案，大部分由C++实现，部分用python实现视觉的特征提取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SensorsCalibration</span><br><span class="line">|-- SensorsX2car</span><br><span class="line">|-- ...</span><br><span class="line">|-- lidar2camera</span><br><span class="line">    |-- auto_calib</span><br><span class="line">    |-- ...</span><br><span class="line">    |-- manul_calib</span><br><span class="line">        |-- data</span><br><span class="line">        |-- include</span><br><span class="line">        |-- src</span><br></pre></td></tr></table></figure><p>（1）例如我们选择用手动标记雷达到相机的方案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> lidar2camera/manul_calib</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>（2）进行标定</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /PATH_TO_manual_calib/</span><br><span class="line">./bin/run_lidar2camera data/0.png data/0.pcd data/center_camera-intrinsic.json data/top_center_lidar-to-center_camera-extrinsic.json</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要记录使用opencalib来标定相机和激光雷达。在一般的多传感器融合方案中，激光雷达投影到相机的思路是应用最广泛的。&lt;/p&gt;
&lt;h2 id=&quot;center-opencalib&quot;&gt;&lt;center&gt; Opencalib&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://gi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nn_trick</title>
    <link href="https://nuclearslippers.github.io/nn-trick/"/>
    <id>https://nuclearslippers.github.io/nn-trick/</id>
    <published>2025-03-05T14:44:18.000Z</published>
    <updated>2025-03-06T07:38:39.523Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录一些深度网络升点的技巧。<a href="https://www.zhihu.com/question/540433389">参考资料</a></p><h2 id="center-升点"><center> 升点</h2><p>AI performance = data(70%) + model(20%) + trick(10%)，数据是对AI性能影响最大的。</p><h3 id="数据处理">数据处理</h3><ol><li><p>数据增强 (Data Augmentation)<br>（1）NLP：回译，词性替换<br>（2）CV：<br>resize、 crop、flip、ratate、blur、HSV变化、affine（仿射）、perspective（透视）、Mixup、cutout、cutmix、Random Erasing（随机擦除）、Mosaic（马赛克）、CopyPaste、GANs domain transfer等</p></li><li><p>pseudo label / meta pseudo label （伪标签，半监督学习，比赛常用）<br>（1）pseudo label：伪标签是一种半监督学习方法，旨在利用有限的标注数据和大量的未标注数据来提升模型的性能。<br>其核心思想是通过一个初步训练的模型对未标注数据进行预测，并将这些预测结果作为“伪标签”，然后将这些伪标签与标注数据一起用于进一步训练模型。<br>（2）meta pseudo label是一种改进的伪标签方法，旨在解决传统伪标签方法中存在的确认偏差问题。它通过引入一个动态更新的教师模型，根据学生模型在标注数据上的表现来调整伪标签的生成过程。<br>学生模型使用教师模型生成的伪标签数据进行训练，教师模型根据学生模型在标注数据上的表现进行更新，以生成更准确的伪标签。</p></li><li><p>噪声数据删除<br>（1）最大熵删除法：构建一个模型来使得信息熵最大，从而区分噪声和真实数据。<br>（2）cleanlab</p></li><li><p>错误标注数据修改：交叉验证训练多个模型，取模型预测结果一致且prob比threshold大的数据（或者topN）。多个模型可以采用不同的seed，不同的训练集测试机，或者不同的模型结果（bert与textcnn等），找出覆盖部分模型预测与标柱数据不一致的标注错误数据进行修改。</p></li></ol><h3 id="模型">模型</h3><p>1… 模型选择<br>先行业数据预训练，使用行业数据进行预训练是最优选择。<br>再领域再训练，在已经有一定通用预训练基础的模型上，使用特定领域的数据进行进一步训练。<br>最后考虑使用公开的模型进行 finetune（微调）</p><h3 id="tricks">tricks</h3><ol><li><p>尝试模型初始化方法，不同的分布，分布参数。<br>当你的模型从0开始训练时，你需要给一个初始的网络权重。此时如何选择初始权重对网络有不小的影响。下面是几种常见的初始化方法，排名越前效果越好。<a href="https://arxiv.org/abs/1502.01852">arxiv</a><br>(1) LSUV init<br>(2) Kaming init<br>(3) pytorch default<br>(4) random init</p></li><li><p>不同的预训练模型<br>举例：ImageNet 1K 和 ImageNet 21K ，两者的分类数不同，使得模型对图片细粒度信息的关注不同，后者效果更好。</p></li><li><p>warmup cosine lr scheduler方法（学习率调整）<br><span style="font-size: 0.8em; color: #888;"> 学习率：训练过程中参数更新的步长大小，即朝着最优方向前进的步子大小<br>这是一种学习率优化算法，大致思路是：先预热（逐渐增加），然后余弦退火（像余弦函数一样周期变化，衰减）。这种方法对大模型效果很好。</p></li><li><p>对抗训练提升鲁棒性<br>常用方法：对抗权重扰动（AWP） <a href="https://www.kaggle.com/code/junkoda/fast-awp">实现代码</a></p></li><li><p>随机权重平均(SWA)<br>通过对训练过程中的模型权重进行Avg融合，提升模型鲁棒性，PyTorch有官方实现。</p></li><li><p>test time augmentation(测试时增强)<br>在测试时使用数据增强的方法处理输入数据，然后对多个结果进行融合（平均、投票等方法）</p></li><li><p>结构重参数化<br>在训练阶段，复杂的网络结构能够捕捉到更多的特征和信息，从而实现更高的性能。然而，在推理阶段，复杂的结构会导致计算资源的浪费和推理速度的下降。结构重参数化通过将训练阶段的复杂结构转换为更简单的等效结构，从而在保持性能的同时提高推理效率。<br>（1）实现方法1：卷积层与批归一化层的合并。在训练阶段，卷积层后通常会接一个批归一化（Batch Normalization, BN）层。在推理阶段，可以将这两个层合并为一个等效的卷积层，减少计算复杂度。<br>（2）实现方法2：多分支结构的合并</p></li><li><p>Gradient Checkpointing（梯度检查点）<br>通过减少显存占用来训练更大规模的模型，同时允许使用更大的批量大小以加速收敛。<br>在深度神经网络的训练中，反向传播需要存储每一层的激活值来计算梯度。对于深层网络，这些激活值会占用大量显存。梯度检查点技术通过在前向传播时丢弃部分激活值，并在反向传播时重新计算这些值，从而显著减少显存占用。<br>训练时间增长为代价，来训练更大的模型。</p></li><li><p>Random Seed<br>深度学习中有许多随机，设定随机种子来使得可重复。<br>（1）数据集的随机划分（训练集、验证集、测试集）。<br>（2）数据增强（如随机裁剪、随机翻转）。<br>（3）权重的随机初始化。<br>（4）批量归一化（Batch Normalization）中的随机抽样。<br>（5）Dropout 中的随机丢弃。</p></li><li><p>其它方法<br>蒸馏，</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要记录一些深度网络升点的技巧。&lt;a href=&quot;https://www.zhihu.com/question/540433389&quot;&gt;参考资料&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;center-升点&quot;&gt;&lt;center&gt; 升点&lt;/h2&gt;
&lt;p&gt;AI performance = d</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MOT任务的主要流程</title>
    <link href="https://nuclearslippers.github.io/MOT/"/>
    <id>https://nuclearslippers.github.io/MOT/</id>
    <published>2025-03-04T06:21:59.000Z</published>
    <updated>2025-03-15T02:37:18.399Z</updated>
    
    <content type="html"><![CDATA[<p>主要记录MOT任务的大致流程，包括检测，追踪，评价，可视化中的一些细节</p><h2 id="center-评价"><center> 评价</h2><p>对于MOT任务，业界一般采用<a href="https://github.com/JonathonLuiten/TrackEval">Trackeval</a>来进行计算。本节以测试MOT17的结果为例，简要介绍一下其使用细节。</p><ol><li>选择要评价的数据集<br>常见的公开数据集都以Trackeval作为自己的官方评价工具，提供一个主函数文件。<a href="https://github.com/JonathonLuiten/TrackEval/blob/master/docs/MOTChallenge-Official/Readme.md">MOT17</a>也是如此，我们在Trackeval库中可以找到<code>run_mot_challenge.py</code>文件。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python scripts/run_mot_challenge.py --BENCHMARK MOT17 --SPLIT_TO_EVAL train --TRACKERS_TO_EVAL MPNTrack --METRICS HOTA CLEAR Identity VACE --USE_PARALLEL False --NUM_PARALLEL_CORES 1  </span><br></pre></td></tr></table></figure><ol start="2"><li>前期准备<br>(1) gt数据准备<br>准备真值，注意格式要符合要求<br>(2) sequences file准备<br>这是备注需要测试的段名</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TrackEval/data/gt/mot_challenge</span><br><span class="line">|——MOT17</span><br><span class="line">    |—— &lt;SeqName01&gt;</span><br><span class="line">        |—— gt</span><br><span class="line">            |—— gt.txt</span><br><span class="line">        |—— seqinfo.ini</span><br><span class="line">    |—— &lt;SeqName02&gt;</span><br><span class="line">        |—— ...</span><br><span class="line">    |—— &lt;SeqName03&gt;</span><br><span class="line">        |—— ...</span><br><span class="line">|——seqmaps</span><br><span class="line">    |——MOT17.txt</span><br></pre></td></tr></table></figure><p>(3) 追踪结果准备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TrackEval/data/gt/trackers/mot_challenge</span><br><span class="line">|——MOT17</span><br><span class="line">    |—— &lt;TrackerName01&gt;</span><br><span class="line">        |—— data</span><br><span class="line">            |—— &lt;SeqName01&gt;.txt</span><br><span class="line">            |—— &lt;SeqName02&gt;.txt</span><br><span class="line">            |—— &lt;SeqName03&gt;.txt</span><br><span class="line">            |—— ...</span><br><span class="line">    |—— &lt;TrackerName02&gt;</span><br><span class="line">        |—— data</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要记录MOT任务的大致流程，包括检测，追踪，评价，可视化中的一些细节&lt;/p&gt;
&lt;h2 id=&quot;center-评价&quot;&gt;&lt;center&gt; 评价&lt;/h2&gt;
&lt;p&gt;对于MOT任务，业界一般采用&lt;a href=&quot;https://github.com/JonathonLuiten/T</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>论文阅读：strongsort</title>
    <link href="https://nuclearslippers.github.io/strongsort/"/>
    <id>https://nuclearslippers.github.io/strongsort/</id>
    <published>2025-02-23T07:07:53.000Z</published>
    <updated>2025-02-23T08:49:40.764Z</updated>
    
    <content type="html"><![CDATA[<p>本文是论文“StrongSORT: Make DeepSORT Great Again”的阅读记录</p><h2 id="center-论文概述"><center> 论文概述</h2><p>StrongSORT论文的主要贡献包括两个部分：对Deepsort的现代化改进（该部分介绍了很多现代技巧），提出两个模块Aflink和GSI。</p><h2 id="center-strongsort"><center> StrongSORT</h2><ol><li>检测器<code>模块升级</code><br>Faster RCNN —&gt; YOLOX</li><li>外貌特征提取器<code>模块升级</code><br>CNN —&gt; BoT</li><li>特征存储机制<code>小问题解决</code><br>为了解决对检测噪声敏感的问题，引入新的特征存储机制（平滑化）方法EMA</li></ol><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>e</mi><mi>i</mi><mi>t</mi></msubsup><mo>=</mo><mi>α</mi><msubsup><mi>e</mi><mi>i</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><msubsup><mi>f</mi><mi>i</mi><mi>t</mi></msubsup></mrow><annotation encoding="application/x-tex">e_i^t=\alpha e_i^{t-1}+(1-\alpha)f_i^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0905559999999999em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8435559999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.131103em;vertical-align:-0.266995em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.433005em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266995em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.093556em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8435559999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>f</mi><mi>i</mi><mi>t</mi></msubsup></mrow><annotation encoding="application/x-tex">f_i^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05222em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.441336em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span> 是原始外貌特征，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>e</mi><mi>i</mi><mi>t</mi></msubsup></mrow><annotation encoding="application/x-tex">e_i^t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05222em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7935559999999999em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span> 是新外貌特征</p><ol start="4"><li>相机移动补偿<code>小问题解决</code><br>文章提到，多数数据集（KITTI,MOT16,DanceTrack）都存在相机移动的问题，因此需要进行运动补偿。采用的方法是ECC</li><li>自适应卡尔曼滤波器 NSA Kalman<code>小问题解决</code><br>常规卡尔曼滤波器收检测噪声和低质量检测的影响都较大，采用一个自适应的噪声协方差来改进。</li></ol><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>R</mi><mo stretchy="true">~</mo></mover><mi>k</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>c</mi><mi>k</mi></msub><mo stretchy="false">)</mo><msub><mi>R</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\widetilde{R}_k=(1-c_k)R_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.09333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94333em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span><span class="svg-align" style="width:calc(100% - 0.16668em);margin-left:0.16668em;top:-3.6833299999999998em;"><span class="pstrut" style="height:3em;"></span><span style="height:0.26em;"><svg width='100%' height='0.26em' viewBox='0 0 600 260' preserveAspectRatio='none'><path d='M200 55.538c-77 0-168 73.953-177 73.953-3 0-7-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128-68.267.847-113-73.952-191-73.952z'/></svg></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">c_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是检测置信度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">R_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是预置协方差。</p><ol start="6"><li>关联方式<code>小问题解决</code><br>不同于Deepsort，新方法采用加权求和。</li></ol><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>λ</mi><msub><mi>A</mi><mi>a</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="false">)</mo><msub><mi>A</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">C = \lambda A_a + (1 - \lambda) A_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">λ</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>0.98</mn></mrow><annotation encoding="application/x-tex">\lambda = 0.98</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span><span class="mord">8</span></span></span></span>是一个自定义权重。<br>之所以采用新的关联方法，是通过实验发现原来复杂的级联关联方式随着追踪器性能的提升，对关联的干扰却变强了。</p><h2 id="center-strongsort"><center> StrongSORT++</h2><p>除了升级以外，本文针对两个问题提出了新的方法和实现。</p><h3 id="aflink">AFlink</h3><p>作者设计该模块的目的是为了解决“关联丢失问题”，即一个目标出现在多个轨迹中，造成该问题的主要原因是数据关联时没考虑全局信息。因此一种直观的解法就是提供长时间的外貌特征存储模块，但这样做的代价是引入了大计算量的网络模块。因此，作者提出一种不需要外貌特征的小型网络AFlink。<br>基本思路就是每个轨迹存储至多30帧位置信息，两个轨迹分别用网络提取特征为一个向量，两个向量相加再用一个分类器得到关联值。排除明显错误之后，匈牙利算法求解即可。<br><em>思考：需要比较该模块的性能影响</em></p><h3 id="gsi">GSI</h3><p>该模块的设计目的是解决检测丢失问题。由于遮挡等原因出现时，检测结果丢失，为了不影响后续追踪效果，往往用方法补上这个检测结果。<br>常用方法：线性插值（简单但效果差），插值加其它模块（KF等）<br>本文提出一种高斯过程回归的插值算法。<br><em>思考：相较于卡尔曼滤波，这种方法引入了一个随机模型（曲线拟合），后续的预测也可以从这入手修改，把KF换了</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是论文“StrongSORT: Make DeepSORT Great Again”的阅读记录&lt;/p&gt;
&lt;h2 id=&quot;center-论文概述&quot;&gt;&lt;center&gt; 论文概述&lt;/h2&gt;
&lt;p&gt;StrongSORT论文的主要贡献包括两个部分：对Deepsort的现代化改进（</summary>
      
    
    
    
    <category term="paper" scheme="https://nuclearslippers.github.io/categories/paper/"/>
    
    
  </entry>
  
  <entry>
    <title>数学表达式</title>
    <link href="https://nuclearslippers.github.io/math-expression/"/>
    <id>https://nuclearslippers.github.io/math-expression/</id>
    <published>2025-02-23T04:34:22.000Z</published>
    <updated>2025-02-23T05:37:30.019Z</updated>
    
    <content type="html"><![CDATA[<p>本文用来记录一些MOT中的数学表达式</p><h2 id="马式距离-mahalanobis-distance">马式距离(Mahalanobis distance)</h2><p>可以看作是欧氏距离的一种修正，修正了欧式距离中各个维度尺度不一致且相关的问题。它考虑了数据的类型，从而使得距离的表达更加有效。（例如身高和体重两个类型的数据。）</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi mathvariant="bold">M</mi></msub><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo separator="true">,</mo><mi mathvariant="bold">y</mi><mo stretchy="false">)</mo><mo>=</mo><msqrt><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo>−</mo><mi mathvariant="bold">y</mi><msup><mo stretchy="false">)</mo><mi mathvariant="normal">T</mi></msup><msup><mi mathvariant="bold">M</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mi mathvariant="bold">x</mi><mo>−</mo><mi mathvariant="bold">y</mi><mo stretchy="false">)</mo></mrow></msqrt></mrow><annotation encoding="application/x-tex">D_{\mathbf{M}}(\mathbf{x}, \mathbf{y}) = \sqrt{(\mathbf{x} - \mathbf{y})^{\mathrm{T}} \mathbf{M}^{-1} (\mathbf{x} - \mathbf{y})} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33027699999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathbf mtight">M</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.5474595em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2925405em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.767331em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">T</span></span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">M</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">x</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span><span class="mclose">)</span></span></span><span style="top:-3.2525405em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M983 90l0 -0c4,-6.7,10,-10,18,-10 H400000v40H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5c53.7,-170.3,84.5,-266.8,92.5,-289.5zM1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5474595em;"><span></span></span></span></span></span></span></span></span></span></p><p>其中 x,y 是数据样本点，M 是协方差矩阵。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文用来记录一些MOT中的数学表达式&lt;/p&gt;
&lt;h2 id=&quot;马式距离-mahalanobis-distance&quot;&gt;马式距离(Mahalanobis distance)&lt;/h2&gt;
&lt;p&gt;可以看作是欧氏距离的一种修正，修正了欧式距离中各个维度尺度不一致且相关的问题。它考虑了数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>偶然学会的小技巧</title>
    <link href="https://nuclearslippers.github.io/nothing-skill/"/>
    <id>https://nuclearslippers.github.io/nothing-skill/</id>
    <published>2025-02-23T01:51:08.000Z</published>
    <updated>2025-02-23T02:06:22.401Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一些偶然用到的小技巧，跟科研无直接关联（也许？）</p><h2 id="center-暴力破解压缩包密码"><center> 暴力破解压缩包密码</h2><p><a href="youtube.com/watch?v=ifrpYn_Gm54">参考资料</a></p><h3 id="大致思路">大致思路</h3><p>借助工具：join the ripper &amp; hashcat，在命令行中运行。</p><ol><li>首先利用join the ripper获得hash值</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rar2john.exe xxxx.rar</span><br></pre></td></tr></table></figure><p>假如我们获得的输出是：&quot;$rar5$16$4ce713ae3e7b5bc7f6ccff8fafa09fcc$15$bd7b7c38adefdb434dfb6424b6280e64$8$f6f2a7f332e958e5&quot;</p><ol start="2"><li>使用hashcat对hash码进行破解</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat.exe -m 13000 -a 3 <span class="built_in">hash</span> -o password.txt</span><br></pre></td></tr></table></figure><ul><li><code>-m 13000</code>: 代表hash的类型值，需要通过hashcat官网进行查询。例如上述例子的类型为  rar5  对应值为13000<br><a href="https://hashcat.net">hashcat官网</a></li><li><code>-a 3</code>: 代表破解类型为掩码攻击，即无字典</li><li><code>-o password.txt</code>: 代表结果保存在该文件里</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文记录一些偶然用到的小技巧，跟科研无直接关联（也许？）&lt;/p&gt;
&lt;h2 id=&quot;center-暴力破解压缩包密码&quot;&gt;&lt;center&gt; 暴力破解压缩包密码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;youtube.com/watch?v=ifrpYn_Gm54&quot;&gt;参考资料&lt;/a&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>tricks</title>
    <link href="https://nuclearslippers.github.io/tricks/"/>
    <id>https://nuclearslippers.github.io/tricks/</id>
    <published>2025-02-20T09:24:21.000Z</published>
    <updated>2025-02-20T09:26:22.320Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录一些刷点的小技巧</p><ol><li>对每个序列进行独立调参<br><a href="https://github.com/ifzhang/ByteTrack/tree/main">BYTE</a><br>“For higher MOTA, you need to carefully tune the test image size and high score detection threshold of each sequence”</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文记录一些刷点的小技巧&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对每个序列进行独立调参&lt;br&gt;
&lt;a href=&quot;https://github.com/ifzhang/ByteTrack/tree/main&quot;&gt;BYTE&lt;/a&gt;&lt;br&gt;
“For higher MOTA, you nee</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>dataset</title>
    <link href="https://nuclearslippers.github.io/dataset/"/>
    <id>https://nuclearslippers.github.io/dataset/</id>
    <published>2025-02-19T09:06:42.000Z</published>
    <updated>2025-02-24T12:02:53.446Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍几个自己用到的数据集</p><h2 id="center-kitti"><center> KITTI</h2><p>KITTI数据集由德国卡尔斯鲁厄理工学院和丰田美国技术研究院联合创办，是一个自动驾驶场景下的大规模数据集。<br>KITTI数据采集平台包括2个灰度摄像机，2个彩色摄像机，一个Velodyne 3D激光雷达，4个光学镜头，以及1个GPS导航系统。<br>往往常用的是左侧彩色摄像头和激光雷达传感器。</p><h3 id="数据格式">数据格式</h3><table><thead><tr><th>Values</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>type</td><td>Describes the type of object: ‘Car’, ‘Van’, ‘Truck’, ‘Pedestrian’, ‘Person_sitting’, ‘Cyclist’, ‘Tram’, ‘Misc’ or ‘DontCare’</td></tr><tr><td>1</td><td>truncated</td><td>Float from 0 (non-truncated) to 1 (truncated), where truncated refers to the object leaving image boundaries</td></tr><tr><td>1</td><td>occluded</td><td>Integer (0,1,2,3) indicating occlusion state:<br>0 = fully visible, 1 = partly occluded<br>2 = largely occluded, 3 = unknown</td></tr><tr><td>1</td><td>alpha</td><td>Observation angle of object, ranging [-pi…pi]</td></tr><tr><td>4</td><td>bbox</td><td>2D bounding box of object in the image (0-based index):<br>contains left, top, right, bottom pixel coordinates</td></tr><tr><td>3</td><td>dimensions</td><td>3D object dimensions: height, width, length (in meters)</td></tr><tr><td>3</td><td>location</td><td>3D object location x,y,z in camera coordinates (in meters)</td></tr><tr><td>1</td><td>rotation_y</td><td>Rotation ry around Y-axis in camera coordinates [-pi…pi]</td></tr><tr><td>1</td><td>score</td><td>Only for results: Float, indicating confidence in detection, needed for p/r curves, higher is better.</td></tr></tbody></table><h3 id="kitti-2d-detection">KITTI 2d Detection</h3><p>下载以下两项即可：</p><ul><li><code>Download left color images of object data set (12 GB)</code></li><li><code>Download training labels of object data set (5 MB)</code></li></ul><h4 id="训练注意事项">训练注意事项</h4><p>类别：‘Car’-汽车, ‘Van’-厢式货车, ‘Truck’-载货卡车, ‘Pedestrian’-行人, ‘Person_sitting’, ‘Cyclist’-骑车人, ‘Tram’-电车, ‘Misc’ or ‘DontCare’</p><h2 id="center-crowdhuman"><center> CrowdHuman</h2><p>CrowdHuman数据集是旷世发布的用于行人检测的数据集，图片数据大多来自于google搜索。约每张图片包含23个人，同时存在各种各样的遮挡。每个人类实例都用头部边界框、人类可见区域边界框和人体全身边界框注释。</p><h3 id="数据集准备">数据集准备</h3><p><a href="https://www.crowdhuman.org/download.html">CrowdHuman官网</a><br><a href="https://aistudio.baidu.com/datasetdetail/89331">个人链接</a><br>数据集包括3个train，1一个val，1个test，两个odgt格式的标签文件</p><h3 id="数据处理">数据处理</h3><p>官方给的是odgt标注格式，一般不用。例如，我想用YOLO进行训练，就需要进行格式转换。代码如下<br><a href="https://blog.csdn.net/weixin_46221106/article/details/144813794">odgt标注格式转为yolo格式</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_func</span>(<span class="params">fpath</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Load and parse ODGT file</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> os.path.exists(fpath), <span class="string">f&quot;File not found: <span class="subst">&#123;fpath&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fpath, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fid:</span><br><span class="line">        lines = fid.readlines()</span><br><span class="line">    records = [json.loads(line.strip(<span class="string">&#x27;\n&#x27;</span>)) <span class="keyword">for</span> line <span class="keyword">in</span> lines]</span><br><span class="line">    <span class="keyword">return</span> records</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_crowdhuman_odgt_to_txt</span>(<span class="params">odgt_path, output_dir</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Convert CrowdHuman ODGT annotations to COCO format TXT files</span></span><br><span class="line"><span class="string">    将边界框坐标从[x, y, w, h]转换为[x_center, y_center, w, h]</span></span><br><span class="line"><span class="string">    并进行归一化</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Create output directory if it doesn&#x27;t exist</span></span><br><span class="line">    os.makedirs(output_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create classes.txt</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(output_dir, <span class="string">&#x27;classes.txt&#x27;</span>), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&#x27;person\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load ODGT annotations</span></span><br><span class="line">    bbox_records = load_func(odgt_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Process each record</span></span><br><span class="line">    <span class="keyword">for</span> record <span class="keyword">in</span> bbox_records:</span><br><span class="line">        <span class="comment"># Get image ID</span></span><br><span class="line">        image_id = record[<span class="string">&#x27;ID&#x27;</span>]</span><br><span class="line">        txt_filename = <span class="string">f&quot;<span class="subst">&#123;image_id&#125;</span>.txt&quot;</span></span><br><span class="line">        txt_path = os.path.join(output_dir, txt_filename)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get image size 这里也需要修改</span></span><br><span class="line">        img_path = os.path.join(os.path.dirname(odgt_path),<span class="string">&quot;images&quot;</span>,</span><br><span class="line">                                <span class="string">f&quot;<span class="subst">&#123;image_id&#125;</span>.jpg&quot;</span>)  <span class="comment"># Assuming images are in the same folder as ODGT</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">        img_width, img_height = img.size</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(txt_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> bbox <span class="keyword">in</span> record[<span class="string">&#x27;gtboxes&#x27;</span>]:</span><br><span class="line">                <span class="comment"># 跳过mask标签和需要忽略的框</span></span><br><span class="line">                <span class="keyword">if</span> bbox[<span class="string">&#x27;tag&#x27;</span>] == <span class="string">&#x27;mask&#x27;</span> <span class="keyword">or</span> bbox.get(<span class="string">&#x27;extra&#x27;</span>, &#123;&#125;).get(<span class="string">&#x27;ignore&#x27;</span>, <span class="number">0</span>) == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 获取全身框坐标 [x, y, w, h]</span></span><br><span class="line">                x, y, w, h = bbox[<span class="string">&#x27;fbox&#x27;</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 计算中心点坐标</span></span><br><span class="line">                x_center = x + w / <span class="number">2</span></span><br><span class="line">                y_center = y + h / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 归一化坐标</span></span><br><span class="line">                x_center /= img_width</span><br><span class="line">                y_center /= img_height</span><br><span class="line">                w /= img_width</span><br><span class="line">                h /= img_height</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 写入COCO格式：class_id x_center y_center width height</span></span><br><span class="line">                bbox_str = <span class="string">f&quot;0 <span class="subst">&#123;x_center&#125;</span> <span class="subst">&#123;y_center&#125;</span> <span class="subst">&#123;w&#125;</span> <span class="subst">&#123;h&#125;</span>&quot;</span></span><br><span class="line">                f.write(<span class="string">f&quot;<span class="subst">&#123;bbox_str&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 需要修改的两处</span></span><br><span class="line">    odgt_path = <span class="string">&#x27;./data/val/annotation_val.odgt&#x27;</span>  <span class="comment"># Replace with your ODGT file path</span></span><br><span class="line">    output_dir = <span class="string">&#x27;./data/val/labels&#x27;</span>  <span class="comment"># Replace with desired output directory</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        convert_crowdhuman_odgt_to_txt(odgt_path, output_dir)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;转换完成。标签文件保存在: <span class="subst">&#123;output_dir&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n每个txt文件的格式:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;class_id x_center y_center width height&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;其中class_id=0表示person类&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;注意：坐标格式为COCO格式（中心点坐标 + 宽高）&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;转换过程中出错: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>其中，需要在main函数中修改数据集的位置。以及如果图片不和odgt文件在一个文件夹下，需要修改convert_crowdhuman_odgt_to_txt函数。（PS：这里才发现这个数据集真是从网上爬来的，很多图甚至还有水印，大小也都不一致。）</p><h2 id="center-nuscenes数据集"><center> Nuscenes数据集</h2><p>该数据集是用于自动驾驶的公共大规模数据集，收集了波士顿和新加坡的1000个驾驶场景。相机运行在12Hz，而激光雷达运行在20Hz。</p><h3 id="数据集结构">数据集结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- v1.0-mini</span><br><span class="line">    - maps</span><br><span class="line">        four maps(.jpg)</span><br><span class="line">    - samples</span><br><span class="line">        - CAM_BACK</span><br><span class="line">        - CAM_BACK_LEFT</span><br><span class="line">        - LIDAR_TOP</span><br><span class="line">        - RADAR_BACK_LEFT</span><br><span class="line">        ...(the sensors&#x27; data)</span><br><span class="line">    - sweeps</span><br><span class="line">        same to &#x27;samples&#x27;</span><br><span class="line">        # 过渡帧或中间帧</span><br><span class="line">    - v1.0-mini</span><br><span class="line">        labels</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要介绍几个自己用到的数据集&lt;/p&gt;
&lt;h2 id=&quot;center-kitti&quot;&gt;&lt;center&gt; KITTI&lt;/h2&gt;
&lt;p&gt;KITTI数据集由德国卡尔斯鲁厄理工学院和丰田美国技术研究院联合创办，是一个自动驾驶场景下的大规模数据集。&lt;br&gt;
KITTI数据采集平台包括</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nn_training</title>
    <link href="https://nuclearslippers.github.io/nn-training/"/>
    <id>https://nuclearslippers.github.io/nn-training/</id>
    <published>2025-02-19T06:57:19.000Z</published>
    <updated>2025-02-23T08:46:45.329Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要记录一些GPU训练的内容</p><h2 id="center-gpu情况查看"><center> GPU情况查看</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><ul><li><code>GPU</code>：GPU 编号；</li><li><code>Name</code>：GPU 型号；</li><li><code>Persistence-M</code>：持续模式的状态。持续模式虽然耗能大，但是在新的GPU应用启动时，花费的时间更少，这里显示的是off的状态；</li><li><code>Fan</code>：风扇转速，从0到100%之间变动；</li><li><code>Temp</code>：温度，单位是摄氏度；</li><li><code>Perf</code>：性能状态，从P0到P12，P0表示最大性能，P12表示状态最小性能（即 GPU 未工作时为P0，达到最大工作限度时为P12）。</li><li><code>Pwr</code>:Usage/Cap：能耗；</li><li><code>Memory Usage</code>：显存使用率；</li><li><code>Bus-Id</code>：涉及GPU总线的东西，domain:bus:device.function；</li><li><code>Disp.A</code>：Display Active，表示GPU的显示是否初始化；</li><li><code>Volatile GPU-Util</code>：浮动的GPU利用率；</li><li><code>Uncorr. ECC</code>：Error Correcting Code，错误检查与纠正；</li><li><code>Compute M</code>：compute mode，计算模式。</li></ul><h2 id="超参数调优">超参数调优</h2><p>常见的超参数调优方法：网格搜索、随机搜索和贝叶斯优化</p><ol><li><p>网格搜索<br>网格搜索是一种穷举搜索方法，它通过遍历超参数的所有可能组合来寻找最优超参数。<br>网格搜索适用于超参数数量较少的情况，计算量较大</p></li><li><p>随机搜索<br>随机搜索是一种随机化的搜索方法，它通过随机采样超参数的组合来寻找最优超参数。<br>随机搜索适用于快速寻找较好的超参数组合</p></li><li><p>贝叶斯优化<br>贝叶斯优化首先利用已有的观测数据训练一个高斯过程模型，根据采集函数的结果选择新的超参数组合进行评估。<br>贝叶斯优化则能够在有限的迭代次数内找到全局最优解，适用于精细搜索。<br>随机搜索+贝叶斯优化的组合往往效果不错。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇文章主要记录一些GPU训练的内容&lt;/p&gt;
&lt;h2 id=&quot;center-gpu情况查看&quot;&gt;&lt;center&gt; GPU情况查看&lt;/h2&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    <category term="nn" scheme="https://nuclearslippers.github.io/categories/nn/"/>
    
    
  </entry>
  
  <entry>
    <title>linux_tools</title>
    <link href="https://nuclearslippers.github.io/linux-tools/"/>
    <id>https://nuclearslippers.github.io/linux-tools/</id>
    <published>2025-02-19T06:10:47.000Z</published>
    <updated>2025-02-19T06:26:30.899Z</updated>
    
    <content type="html"><![CDATA[<p>本文大致介绍一下linux里常用工具，如ffmpeg,simple</p><h2 id="center-ffmpeg"><center> ffmpeg</h2><p>ffmpeg是经典的视频（图像）编辑工具，可以实现图片制作视频，视频提取图片，制作GIF等功能。这些都是多目标追踪过程中常用的工具。</p><h3 id="安装">安装</h3><p>Windows下直接搜索官网，在“release build”中找到“ffmpeg-x.x.x-essentials_build.zip”下载即可。<br>解压完成后，将/bin文件的路径添加到系统环境变量中即可。</p><h3 id="图片制作视频">图片制作视频</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -framerate 30 -i %06d.jpg -vf <span class="string">&quot;scale=1544:1080&quot;</span> -c:v libx264 -r 30 -pix_fmt yuv420p output.mp4</span><br></pre></td></tr></table></figure><ul><li><code>-framerate</code>：设置输入图片的帧率为 30 帧每秒</li><li><code>-i</code>：指定输入文件的格式</li><li><code>-s</code>：设置输出视频的分辨率</li><li><code>-c:v</code>：指定视频编码器，如“libx264”</li><li><code>-c:a</code>：指定音频编码器</li><li><code>-r</code>: 设置输出视频的帧率</li><li><code>-pix_fmt yuv420p</code>: 设置像素格式为 yuv420p，这是大多数播放器支持的格式。</li><li><code>name.mp4</code>: 设置输出名</li><li><code>-vf &quot;scale=1544:1080&quot;</code>: 过滤器，调整分辨率</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文大致介绍一下linux里常用工具，如ffmpeg,simple&lt;/p&gt;
&lt;h2 id=&quot;center-ffmpeg&quot;&gt;&lt;center&gt; ffmpeg&lt;/h2&gt;
&lt;p&gt;ffmpeg是经典的视频（图像）编辑工具，可以实现图片制作视频，视频提取图片，制作GIF等功能。这些都是</summary>
      
    
    
    
    <category term="tools" scheme="https://nuclearslippers.github.io/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>bevformer</title>
    <link href="https://nuclearslippers.github.io/bevformer/"/>
    <id>https://nuclearslippers.github.io/bevformer/</id>
    <published>2025-02-17T09:09:27.000Z</published>
    <updated>2025-02-17T11:18:24.758Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录BEVFormer复现中需要注意的一些地方</p><h2 id="torch相关安装">torch相关安装</h2><p>在官方教程中，给了推荐的torch的版本。经过实验，pytorch不要超过1.10，因为它取消了一个特性。<br>[THC/THC.h: No such file or directory报错解决][1]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install torch==1.9.1+cu111 torchvision==0.10.1+cu111 torchaudio==0.9.1 -f https://download.pytorch.org/whl/torch_stable.html</span><br><span class="line"><span class="comment"># Recommended torch&gt;=1.9</span></span><br></pre></td></tr></table></figure><h2 id="mmcv-full的安装">mmcv-full的安装</h2><p>如果按照官方的做法，往往会卡住（科学上网可能会比较顺利），下面提供其它方法。<br>我们通过mmcv-full官方推荐的方法进行下载。<br>[Building wheel for mmcv-full (<a href="http://setup.py">setup.py</a>) … error解决办法][2]</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install -U openmim</span><br><span class="line">mim install mmcv-full==1.4.0</span><br></pre></td></tr></table></figure><h2 id="安装mmdet-and-mmseg">安装mmdet and mmseg</h2><p>正常安装即可</p><h2 id="mmdet3d源码安装">mmdet3d源码安装</h2><p>由于是用的服务器镜像，torch版本和python版本对应不上。需要自行安装torch。</p><h3 id="镜像的选择">镜像的选择</h3><p>[我应该选择哪个 Docker 镜像？][3]<br>Alpine:极小的镜像大小，快速的构建和部署时间，较低的资源消耗。可能存在软件包的新颖性和兼容性问题，较少的库支持。<br>Bookworm：提供最新的安全更新和软件包。<br>Bullseye：提供长期的支持和维护。</p><p>[1]<a href="https://blog.csdn.net/qq_40349484/article/details/134528674">https://blog.csdn.net/qq_40349484/article/details/134528674</a><br>[2]<a href="https://blog.csdn.net/weixin_46412818/article/details/126006081">https://blog.csdn.net/weixin_46412818/article/details/126006081</a><br>[3]<a href="https://cloud.tencent.com/developer/article/2457031">https://cloud.tencent.com/developer/article/2457031</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文记录BEVFormer复现中需要注意的一些地方&lt;/p&gt;
&lt;h2 id=&quot;torch相关安装&quot;&gt;torch相关安装&lt;/h2&gt;
&lt;p&gt;在官方教程中，给了推荐的torch的版本。经过实验，pytorch不要超过1.10，因为它取消了一个特性。&lt;br&gt;
[THC/THC.h: </summary>
      
    
    
    
    <category term="paperwork" scheme="https://nuclearslippers.github.io/categories/paperwork/"/>
    
    
  </entry>
  
  <entry>
    <title>yolo</title>
    <link href="https://nuclearslippers.github.io/yolo/"/>
    <id>https://nuclearslippers.github.io/yolo/</id>
    <published>2025-02-14T02:21:48.000Z</published>
    <updated>2025-02-21T02:46:25.178Z</updated>
    
    <content type="html"><![CDATA[<p>简要介绍yolov5的原理，以及yoloX的提升。</p><h2 id="center-yolov5"><center> YOLOv5</h2><p>YOLO系列的核心思想就是把目标检测转变为一个回归问题，利用整张图片作为网络的输入，通过神经网络，得到边界框的位置及其所属的类别。</p><h3 id="center-组成"><center> 组成</h3><h4 id="backbone">Backbone</h4><p>负责从输入图像中提取有用的特征。在较早的层中提取低层次的特征（如边缘和纹理），在较深层中提取高层次的特征（如物体和语义信息）。</p><h4 id="neck">Neck</h4><p>聚集并细化骨干网提取的特征，通常侧重于加强不同尺度的空间和语义信息。</p><h4 id="head">Head</h4><p>根据特征进行预测，最后非极大值抑制（NMS），过滤掉重叠的预测，只保留置信度最高的检测。</p><h3 id="center-基本工作原理"><center> 基本工作原理</h3><ol><li>数据预处理<br>Mosaic数据增强：按照随机缩放、随机裁剪和随机排布的方式对四幅图像进行拼接。<br>自适应图像缩放：统一缩放到一个标准尺寸</li><li>网络结构</li></ol><ul><li>Focus：特殊的下采样模块</li><li>CSP：CSP1_X应用于backbone主干网络部分，backbone是较深的网络，增加残差结构可以增加层与层之间反向传播的梯度值，避免因为层数加深而带来的梯度消失。CSP2_X相对于CSP1_X来说，将Resunit换成了2 * X个CBS，主要应用在Neck网络 （网络没那么深）。</li><li>FPN-PAN（Neck）:FPN层自顶向下传达强语义特征，而PAN是自底向上传达定位特征.FPN特征金字塔利用浅层特征将简单目标区分开，利用深层特征将复杂目标区分开。PAN自下而上传达定位特征</li><li>SPP:金字塔池化，可将任意大小的特征图转换成固定大小的特征向量。</li></ul><ol start="3"><li>预测模块</li></ol><ul><li>GIOU：当预测框和GT框不相交时，即IOU=0，此时无法反映两个框之间的距离，损失函数不可导。当两个预测框交集大小相同时，两个IOU也相同。</li><li>NMS：如果物体很大，而网格又很小，一个物体可能会被多个网格识别。选择预测类别置信度高的里留下，其余预测都删除。把置信度最高网格的预测框作为极大预测框，计算极大预测框和其他几个网格预测框的IOU，如果超过一个阈值，例如0.5，则认为这两个网格实际上预测的是同一个物体，就把其中置信度比较小的删除。</li></ul><h2 id="center-yolox的改进"><center> YOLOX的改进</h2><h3 id="检测头解耦">检测头解耦</h3><p>将分类（Cls）、回归（Reg）和置信度（Obj）分支分离，通过独立的卷积层处理每个任务。而YOLOv5使用耦合检测头，三者共享同一卷积层。解耦设计能加速模型收敛并提升检测精度，例如在YOLOX中AP（平均精度）提升约1.1%</p><h3 id="无锚框-anchor-free">无锚框（Anchor-Free）</h3><p>直接预测边界框的偏移量和尺寸（类似FCOS方法）。这不仅简化了模型设计，还减少了对锚框超参数的依赖，提升了泛化能力。</p><h3 id="训练策略">训练策略</h3><p>YOLOX引入SimOTA（简化版最优传输分配），通过全局优化匹配正负样本，替代了YOLOv5基于IoU阈值的静态分配。SimOTA能更高效地解决目标重叠和小样本问题，在COCO数据集上AP提升约2.3%。</p><h3 id="数据增强">数据增强</h3><p>YOLOX在输入端采用更强的数据增强组合（如Mosaic和MixUp）。</p><h3 id="性能">性能</h3><p>YOLOX在相同分辨率（如640×640）下，AP略高于YOLOv5。<br>YOLOX支持端到端训练（End-to-End模式），无需后处理NMS（非极大值抑制），而YOLOv5依赖NMS过滤冗余框。此外，YOLOX提供多种轻量化版本（如Nano、Tiny），适合移动端部署。<br>YOLOX通过多尺度特征融合和强数据增强，对小目标检测效果更优，而YOLOv5在复杂场景中的鲁棒性更强。</p><h2 id="center-yolov11实战"><center> YOLOv11实战</h2><p>yolov5,v8,v11都是由ultralytics公司制作的yolo系列</p><h3 id="模型参数">模型参数</h3><ul><li><code>Latency</code>:延迟，是指模型推理和后处理的时间。这个指标用于衡量模型处理一张图片或进行一次预测所需的时间，时间越小，执行速度越快。默认情况下，Latency的时间计算是不包含图像解码和前处理的时间的，因为这两部分时间的影响因素较多，包括图像文件的读取速度、前处理操作（如标准化、张量化以及数据移动到显卡）的复杂度和硬件性能等。</li><li><code>FLOPs</code>:浮点运算次数，衡量模型计算复杂度。高FLOPs意味着模型具有更高的计算复杂度，需要更多的计算资源来训练和推理。注意和FLOPS区分，S大写的是硬件的运算能力参数。</li><li><code>Parameters</code>:模型的参数量。</li></ul><h3 id="训练">训练</h3><ol><li><p>数据集准备<br>YOLO的标签有固定的格式，注意数据是经过归一化的。<br>COCO格式：<code>class x_center y_center width height</code></p></li><li><p>开始训练<br>YOLOv11的封装做的非常好，仅需几行代码就能够完成训练设置。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import warning</span></span><br><span class="line"><span class="comment"># warning.filterwarnings(&quot;ignore&quot;)</span></span><br><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    model = YOLO(<span class="string">&quot;weights/yolo11x.pt&quot;</span>)  <span class="comment"># load a pretrained model</span></span><br><span class="line"></span><br><span class="line">    results = model.train(data=<span class="string">&quot;data.yaml&quot;</span>,</span><br><span class="line">                        epochs=<span class="number">100</span>, imgsz=<span class="number">640</span>,</span><br><span class="line">                        batch=<span class="number">16</span>,</span><br><span class="line">                        workers=<span class="number">20</span>,</span><br><span class="line">                        device=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                        amp=<span class="literal">True</span>,</span><br><span class="line">                        patience=<span class="number">30</span>)  <span class="comment"># train the model</span></span><br></pre></td></tr></table></figure><p>训练参数设置：</p><ul><li><code>batch_size</code>：每次迭代中用于训练的网络输入样本数量。较大的批次可能提高训练效率，但也可能增加内存消耗。</li><li><code>learning_rate</code>：学习率决定了权重调整的幅度。较小的学习率意味着模型在训练过程中更新更慢，而较大的学习率可能导致模型在最优解附近震荡。</li><li><code>epochs</code>：整个训练数据集被遍历的次数。一个epoch意味着每个训练样本都被网络学习了一次。</li><li><code>patience</code>:等待验证指标无改进而提前停止训练的 epoch 数量。通过在性能停滞时停止训练，有助于防止过拟合。</li><li><code>momentum</code>：动量参数用于加速SGD在相关方向上的优化，并抑制震荡。</li><li><code>lr0</code>: 初始学习率，调整此值对于优化过程至关重要，影响模型权重更新的速度。</li><li><code>workers</code>: 工作线程数量用于数据加载（每个 GPU）。影响数据预处理和模型输入的速度，在多 GPU 设置中特别有用。</li><li><code>device</code>: 指定用于训练的计算设备</li><li><code>data</code>: 数据集配置文件路径（例如， coco8.yaml ）。此文件包含数据集特定的参数，包括训练和验证数据路径、类别名称和类别数量。</li></ul><p>更多见<a href="https://docs.ultralytics.com/modes/train/#resuming-interrupted-trainings">ultraltics官方文档：训练</a></p><ol start="3"><li>结果分析<br>参考资料：<a href="https://blog.csdn.net/weixin_45751396/article/details/126726120">YOLO-V5训练结果的分析与评价</a>，<a href="https://blog.csdn.net/LWD19981223/article/details/131241215">参考2</a></li></ol><ul><li><code>confusion_matrix</code>：混淆矩阵，是特别用于监督学习的可视化工具。<br>矩阵的每一列代表一个类的实例预测，而每一行表示一个实际的类的实例。之所以如此命名，是因为通过这个矩阵可以方便地看出机器是否将两个不同的类混淆了（比如说把一个类错当成了另一个）。<br>即每一行是预测类别。每一列是真实类别。</li><li><code>P_curve</code>:(precision)单一类准确率,预测为positive的准确率。<br>意思就是，当设置置信度为某一数值的时候，各个类别识别的准确率。</li><li><code>R_curve</code>:(recall)真实为positive的准确率，即正样本有多少被找出来了（召回了多少）。<br>意思就是，当设置置信度为某一数值的时候，各个类别查全的概率。</li><li><code>PR_curve</code>:希望更加接近于（1，1）</li><li><code>F1_curve</code>:是分类问题的一个衡量指标，是多分类问题的关键性指标。<br>它是精确率和召回率的调和平均数，最大为1，最小为0。</li><li><code>labels</code>:该图是标签的可视化（和模型的性能没直接关联）<br>(1) 第一个图是训练集得数据量，每个类别有多少个<br>(2) 第二个是框的尺寸和数量<br>(3) 第三个是center点的位置<br>(4) 第四个是label的高宽</li><li><code>labels_correlogram</code>:对标签不同属性相关性的分析<br>x, y, width, height 4个变量之间的关系</li><li><code>result.png&amp;result.txt</code><br>横坐标是训练轮次，纵坐标是各个指标。<br>(1) box_loss: 定位损失，预测框与标定框之间的误差（GIoU）<br>(2) obj_loss: 目标存在损失，模型预测的目标存在概率<br>(3) cls_loss: 分类损失，度量预测类别与真实类别的差异<br>(4) mAP50-95: 表示在不同IoU阈值（从0.5到0.95，步长0.05）的mAP<br>(5) mAP50: 表示阈值大于0.5的平均mAP<br>(6) mAP: 平均准确率均值，是根据PR曲线计算得到的</li></ul><ol start="4"><li>遇见的问题</li></ol><ul><li><code>docker环境</code>：opencv需要额外的库</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python-headless</span><br></pre></td></tr></table></figure><ul><li><code>多卡训练</code>：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> MKL_SERVICE_FORCE_INTEL=1</span><br><span class="line"><span class="built_in">export</span> MKL_THREADING_LAYER=GNU</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简要介绍yolov5的原理，以及yoloX的提升。&lt;/p&gt;
&lt;h2 id=&quot;center-yolov5&quot;&gt;&lt;center&gt; YOLOv5&lt;/h2&gt;
&lt;p&gt;YOLO系列的核心思想就是把目标检测转变为一个回归问题，利用整张图片作为网络的输入，通过神经网络，得到边界框的位置及其所</summary>
      
    
    
    
    <category term="AI" scheme="https://nuclearslippers.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>BEV</title>
    <link href="https://nuclearslippers.github.io/BEV/"/>
    <id>https://nuclearslippers.github.io/BEV/</id>
    <published>2025-02-13T03:55:43.000Z</published>
    <updated>2025-02-13T04:24:04.796Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要大致介绍一种新的感知框架：BEV。<br>参考资料：<a href="https://news.qq.com/rain/a/20240406A01GE400">自动驾驶中常聊的BEV感知到底是什么？</a>,<a href="https://blog.csdn.net/sgzqc/article/details/137977541">小白也能看懂的BEV感知技术（二）</a></p><h2 id="center-什么是感知模块"><center> 什么是感知模块</h2><p>以多种传感器的数据与高精度地图的信息为输入，经过一系列的计算和处理，对周围环境精确感知的系统，作用相当于人眼。其感知识别任务本质上是对物理世界进行3D几何重构，使计算机能够“认识”到物理世界中的实体和元素。</p><h2 id="center-bev的出现"><center> BEV的出现</h2><p>随着车辆上搭载的传感器越来越多、越来越复杂，且安装位置、视角和数据格式不尽相同，因此，以统一的视角将来自不同传感器的多源信息进行数据整合，在统一的视图中表示特征变得至关重要。<br>BEV的英文全称为Bird’s-Eye-View，即鸟瞰视图，它模拟了从正上方垂直向下观看地球表面的效果，能够清晰地显示地形、建筑物、道路网络等地理要素之间的空间关系和布局。这种视图对于自动驾驶车辆而言至关重要，因为它简化了对周围环境的感知和理解。</p><h2 id="center-bev的特点"><center> BEV的特点</h2><h3 id="优势">优势</h3><ul><li>没有2D感知中常见的遮挡或缩放问题。识别有遮挡或交叉的车辆可以得到更好的解决。</li><li>以这种形式表示对象或道路元素有利于后续模块(如规划、控制)的开发和部署。</li><li>全局视野与统一坐标框架。将来自不同传感器（如摄像头、雷达、LiDAR）的数据转换到同一BEV坐标系下，使得所有感知信息在一个标准化的空间内融合和处理，增强了信息的一致性和可靠性。</li><li>多任务处理与并行化。</li><li>降低硬件成本与依赖。</li></ul><h3 id="不足">不足</h3><ul><li>深度感知精度的不确定性，依赖雷达等传感器</li><li>传感器融合及校准难题</li><li>环境感知局限</li><li>动态环境适应性，实时处理动态变化的交通场景（如快速移动物体）对计算资源需求巨大，同时要求算法能快速响应和更新BEV视图</li><li>环境因素</li></ul><h2 id="center-bev的工作原理"><center> BEV的工作原理</h2><ol><li>传感器的数据获取：包括但不限于来自相机的RGB图像、深度图像，或激光雷达的点云数据等。</li><li>数据预处理：校正畸变、滤波、去除噪声等。</li><li>BEV视角转换：技术关键<br>大致可以分为两种方法：基于几何变换和基于网络变换。<h4 id="基于几何变换">基于几何变换</h4><pre><code> - 视觉类：估计深度（深度学习网络，多目视觉）；结合内外参，通过三维空间几何变化  映射到BEV空间。 - 激光雷达：点云数据已经是三维形式，可以直接通过坐标变换（旋转和平移）将点云数据转换到车辆坐标系下的BEV视图。这通常较为简单且精确，但涉及到大量的数据稀疏性和不规则性处理。</code></pre><h4 id="基于网络变换">基于网络变换</h4><pre><code> - 端到端训练，从输入图像直接输出BEV空间下的特征图。 - 特征提取结合深度估计信息，采用反投影到BEV空间中。</code></pre></li><li>多模态数据融合<br>各传感器获得的BEV视角数据进行融合，整合形成一个全面且精确的周围环境表示。通过结合不同传感器的优势互补缺失，例如雷达对于非可视条件下的探测能力，摄像头对于颜色和纹理的识别能力，激光雷达对于精准距离测量的能力。</li><li>特征提取与建模：利用深度学习模型（如Transformer或者CNN等）提取和构建环境特征图，用于识别和追踪路面、车辆、行人、交通标志等关键元素。</li><li>感知任务执行：目标检测、分类、轨迹预测等，从而让自动驾驶系统了解周围环境的状态，并据此做出决策。</li><li>端到端优化：最新的BEV感知技术如LSS（Lift, Splat, Shoot）或BEVFormer等，实现了端到端的训练，可以直接从原始传感器输入到BEV特征的生成，同时进行感知任务的学习和优化，提高了整个系统的效率和性能。</li></ol><h2 id="center-代表工作"><center> 代表工作</h2><h4 id="视觉bev">视觉BEV</h4><ul><li>基于几何变换：BEVDepth、Mono3D</li><li>端到端：BEVFormer</li></ul><h4 id="激光bev">激光BEV</h4><h4 id="融合bev">融合BEV</h4><p>融合的方式包括早期融合（数据级融合）、中期融合（特征级融合）和后期融合（决策级融合）等多种策略。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要大致介绍一种新的感知框架：BEV。&lt;br&gt;
参考资料：&lt;a href=&quot;https://news.qq.com/rain/a/20240406A01GE400&quot;&gt;自动驾驶中常聊的BEV感知到底是什么？&lt;/a&gt;,&lt;a href=&quot;https://blog.csdn.n</summary>
      
    
    
    
    <category term="tracking theory" scheme="https://nuclearslippers.github.io/categories/tracking-theory/"/>
    
    
    <category term="tracking" scheme="https://nuclearslippers.github.io/tags/tracking/"/>
    
  </entry>
  
  <entry>
    <title>pytorch</title>
    <link href="https://nuclearslippers.github.io/pytorch/"/>
    <id>https://nuclearslippers.github.io/pytorch/</id>
    <published>2025-02-12T03:19:33.000Z</published>
    <updated>2025-02-14T03:53:10.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pytorch">Pytorch</h2><h3 id="torch-nn">torch.nn</h3><p>torch.nn的基础功能：</p><ol><li>创建神经网络</li><li>训练神经网络</li><li>保存神经网络</li><li>恢复神经网络</li></ol><h4 id="nn-linear类-全连接层">nn.Linear类（全连接层）</h4><p>用于创建一个多输入、多输出的全连接层，注意本身并不包含激活函数（Functional）。</p><p><strong>CLASS torch.nn.Linear</strong></p><ul><li><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = nn.Linear(in_features=<span class="number">5</span>, out_features=<span class="number">10</span>, bias=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>参数说明</strong><br>in_features：<br>输入的二维张量的大小。一般大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n \times i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>。其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 代表样本数（batch size），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 代表特征数。对于图片数据，特征数可能是多个维度相乘的形式。</p><p>out_features：<br>输出的二维张量的大小。这个参数指定了线性层输出的特征维度。</p></li></ul><h4 id="nn-functional-常见函数">nn.functional（常见函数）</h4><p>nn.functional定义了创建神经网络所需要的一些常见的处理函数。如没有激活函数的神经元，各种激活函数等。<br><strong>torch.nn.functional</strong></p><ul><li><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output = nn.functional.relu(<span class="built_in">input</span>)</span><br><span class="line">output = nn.functional.sigmoid(<span class="built_in">input</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>参数说明</strong><br>in_features：<br>一般大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>×</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">n \times i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>。其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 代表样本数（batch size），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 代表特征数。对于图片数据，特征数可能是多个维度相乘的形式。</p></li></ul><p>nn.Xxx和nn.functional.xxx的差别<br>（1）大小写（2）nn.Xxx的属性更多</p><h4 id="nn-module">nn.Module</h4><p>一个抽象概念，表示一个网络层，或者一个网络</p><p><strong>维度问题</strong></p><ul><li>Epoch:<br>时期、轮次。当一个完整的数据集通过了神经网络一次并且返回了一次，这个过程称为一个epoch</li><li>Batch:<br>批。一个Epoch的样本数量可能太过庞大，需要把它分成多个小块，也就是分成多个Batch来进行训练</li><li>Batc_Size:<br>每批样本的大小。Batch Size变大，梯度变准确，但是对计算资源的要求也变大。</li></ul><p><strong>处理技巧</strong></p><ul><li>Dropout<br>在训练神经网络时随机丢弃（即设置为零）网络层中的一部分神经元输出。这是正则化技术的一种，旨在减少模型的过拟合，提高模型的泛化能力。</li><li>FeedForward<br>用于增加模型的非线性能力</li><li>NormLayer<br>稳定训练过程和加速收敛</li></ul><h2 id="写在后面：如何判断你对pytorch有一定的了解？">写在后面：如何判断你对Pytorch有一定的了解？</h2><p>答案来自：KIMI1.5</p><ol><li>什么是张量（Tensor）？它和 NumPy 中的数组有什么区别和联系？<br>张量是 PyTorch 中的基本数据结构，用于存储数据和计算操作。与 NumPy 数组相比，张量可以利用 GPU 加速计算，且与 PyTorch 的自动求导（autograd）系统紧密结合，方便进行梯度计算和模型训练。</li><li>梯度爆照和梯度消失<br>梯度消失：梯度趋近于零，网络权重无法更新或更新的很微小，网络训练再久也不会有效果；<br>梯度爆炸：梯度呈指数级增长，变的非常大，然后导致网络权重的大幅更新，使网络变得不稳定。<br>出现原因：反向传播中多层网络导致的。1.1^x 0.9^x<br>梯度爆照的处理：<br>梯度裁剪，梯度超过这个阈值，那么就将其强制限制在这个范围之内。<br>网络权重正则化<br>换激活函数：ReLu,Leaky Relu<br>BatchNorm<br>梯度消失：<br>换激活函数：ReLu,Leaky Relu<br>BatchNorm<br>残差结构</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;pytorch&quot;&gt;Pytorch&lt;/h2&gt;
&lt;h3 id=&quot;torch-nn&quot;&gt;torch.nn&lt;/h3&gt;
&lt;p&gt;torch.nn的基础功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建神经网络&lt;/li&gt;
&lt;li&gt;训练神经网络&lt;/li&gt;
&lt;li&gt;保存神经网络&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="AI" scheme="https://nuclearslippers.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>Kalman</title>
    <link href="https://nuclearslippers.github.io/Kalman/"/>
    <id>https://nuclearslippers.github.io/Kalman/</id>
    <published>2025-02-12T02:05:04.000Z</published>
    <updated>2025-02-12T10:17:19.377Z</updated>
    
    <content type="html"><![CDATA[<p>卡尔曼滤波在目标跟踪中的作用大致可以分为两个部分：预测和最优估计。</p><h2 id="数学原理">数学原理</h2><ol><li><strong>状态预测方程</strong>：</li></ol><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mi mathvariant="bold">A</mi><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi mathvariant="bold">B</mi><msub><mi mathvariant="bold">u</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">   \mathbf{\hat{x}}_{k|k-1} = \mathbf{A} \mathbf{\hat{x}}_{k-1|k-1} + \mathbf{B} \mathbf{u}_{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0630799999999998em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.70788em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span><span style="top:-3.01344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2875em;"><span class="mord mathbf">^</span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0630799999999998em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.70788em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span><span style="top:-3.01344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2875em;"><span class="mord mathbf">^</span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.894441em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathbf">B</span></span><span class="mord"><span class="mord"><span class="mord mathbf">u</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{\hat{x}}_{k|k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0630799999999998em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.70788em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span><span style="top:-3.01344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2875em;"><span class="mord mathbf">^</span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span> 是状态预测值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">A</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">A</span></span></span></span></span> 是状态转移矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">B</mi></mrow><annotation encoding="application/x-tex">\mathbf{B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">B</span></span></span></span></span> 是控制矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">u</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{u}_{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.652771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">u</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 是控制输入。</p><ol start="2"><li><strong>预测误差协方差方程</strong>：</li></ol><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mi mathvariant="bold">A</mi><msub><mi mathvariant="bold">P</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mi mathvariant="bold">A</mi><mi>T</mi></msup><mo>+</mo><mi mathvariant="bold">Q</mi></mrow><annotation encoding="application/x-tex">   \mathbf{P}_{k|k-1} = \mathbf{A} \mathbf{P}_{k-1|k-1} \mathbf{A}^T + \mathbf{Q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04131em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2465309999999998em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathbf">A</span></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">A</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8805499999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathbf">Q</span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{P}_{k|k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04131em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span> 是预测误差协方差矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">Q</mi></mrow><annotation encoding="application/x-tex">\mathbf{Q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8805499999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathbf">Q</span></span></span></span></span> 是过程噪声协方差矩阵。</p><ol start="3"><li><strong>卡尔曼增益方程</strong>：</li></ol><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">K</mi><mi>k</mi></msub><mo>=</mo><msub><mi mathvariant="bold">P</mi><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mi mathvariant="bold">H</mi><mi>T</mi></msup><mo stretchy="false">(</mo><mi mathvariant="bold">H</mi><msub><mi mathvariant="bold">P</mi><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mi mathvariant="bold">H</mi><mi>T</mi></msup><mo>+</mo><mi mathvariant="bold">R</mi><msup><mo stretchy="false">)</mo><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">   \mathbf{K}_k = \mathbf{P}_{k|k-1} \mathbf{H}^T (\mathbf{H} \mathbf{P}_{k|k-1} \mathbf{H}^T + \mathbf{R})^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">K</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2465309999999998em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">H</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">H</span></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">H</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbf">R</span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">K</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{K}_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">K</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是卡尔曼增益，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">H</mi></mrow><annotation encoding="application/x-tex">\mathbf{H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">H</span></span></span></span></span> 是观测矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">R</mi></mrow><annotation encoding="application/x-tex">\mathbf{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">R</span></span></span></span></span> 是观测噪声协方差矩阵。</p><ol start="4"><li><strong>状态更新方程</strong>：</li></ol><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi></mrow></msub><mo>=</mo><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi mathvariant="bold">K</mi><mi>k</mi></msub><mo stretchy="false">(</mo><msub><mi mathvariant="bold">z</mi><mi>k</mi></msub><mo>−</mo><mi mathvariant="bold">H</mi><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">   \mathbf{\hat{x}}_{k|k} = \mathbf{\hat{x}}_{k|k-1} + \mathbf{K}_k (\mathbf{z}_k - \mathbf{H} \mathbf{\hat{x}}_{k|k-1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0630799999999998em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.70788em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span><span style="top:-3.01344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2875em;"><span class="mord mathbf">^</span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0630799999999998em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.70788em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span><span style="top:-3.01344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2875em;"><span class="mord mathbf">^</span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">K</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathbf">z</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord mathbf">H</span></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.70788em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span><span style="top:-3.01344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2875em;"><span class="mord mathbf">^</span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{\hat{x}}_{k|k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0630799999999998em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.70788em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span><span style="top:-3.01344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2875em;"><span class="mord mathbf">^</span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span> 是更新后的状态估计值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">z</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{z}_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.59444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">z</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是观测值。</p><ol start="5"><li><strong>更新误差协方差方程</strong>：</li></ol><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="bold">I</mi><mo>−</mo><msub><mi mathvariant="bold">K</mi><mi>k</mi></msub><mi mathvariant="bold">H</mi><mo stretchy="false">)</mo><msub><mi mathvariant="bold">P</mi><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">   \mathbf{P}_{k|k} = (\mathbf{I} - \mathbf{K}_k \mathbf{H}) \mathbf{P}_{k|k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04131em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathbf">I</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">K</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">H</span></span><span class="mclose">)</span><span class="mord"><span class="mord"><span class="mord mathbf">P</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="bold">P</mi><mrow><mi>k</mi><mi mathvariant="normal">∣</mi><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathbf{P}_{k|k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04131em;vertical-align:-0.3551999999999999em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mtight">∣</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span></span></span></span> 是更新后的误差协方差矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="bold">I</mi></mrow><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">I</span></span></span></span></span> 是单位矩阵。</p><h2 id="在追踪任务中的应用">在追踪任务中的应用</h2><h3 id="最优估计">最优估计</h3><p>可以理解为将过去轨迹和当前检测结果加权，得到一个更加平滑的结果。</p><h3 id="预测">预测</h3><p>根据模型（往往采用的是匀速直线运动模型）计算得到下一时刻的目标状态，使得匹配更加准确（因为目标在运动）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;卡尔曼滤波在目标跟踪中的作用大致可以分为两个部分：预测和最优估计。&lt;/p&gt;
&lt;h2 id=&quot;数学原理&quot;&gt;数学原理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;状态预测方程&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span c</summary>
      
    
    
    
    <category term="tracking theory" scheme="https://nuclearslippers.github.io/categories/tracking-theory/"/>
    
    
  </entry>
  
  <entry>
    <title>Lidar</title>
    <link href="https://nuclearslippers.github.io/Lidar/"/>
    <id>https://nuclearslippers.github.io/Lidar/</id>
    <published>2025-02-12T01:00:47.000Z</published>
    <updated>2025-02-12T10:17:35.299Z</updated>
    
    <content type="html"><![CDATA[<p>简要介绍激光雷达的原理</p><h2 id="基本原理">基本原理</h2><h3 id="测距原理">测距原理</h3><p>激光反射，根据飞行时间ToF来计算目标物体的距离。x = ct/2</p><h3 id="扫描原理">扫描原理</h3><p>大致分为两个大类：机械旋转、固态扫描（光学相控阵，微机电系统）<br>无人机常用的mid360采用的是光学相控阵，原理是光栅衍射。</p><h2 id="点云预处理">点云预处理</h2><p>重采样：包括增加数据和减少数据。上采样一般方法有：插值。常常用作填充缺失的点。下采样：统计滤波，高斯滤波：高斯函数进行加权平滑数据，深度学习。常常用来降噪。</p><h2 id="目标检测">目标检测</h2><h3 id="centerpoint">Centerpoint</h3><p>摘自：<a href="https://blog.csdn.net/qq_53909832/article/details/132873712">centerpoint</a></p><p>1.输入:点云数据P<br>2.经过3D编码器(如VoxelNet或者PointPillars),生成俯视图特征图M<br>3.进入检测头,首先是一个可学习的3x3卷积层、BN层、ReLU激活函数<br>4.分支到两个头:<br>(1) 中心点heatmap头:进行几个卷积生成K个热力图,表示K类目标的中心点置信度<br>(2) 回归头:进行几个卷积,生成所有类别共享的回归目标,包括坐标回归、尺寸回归、高度回归、旋转回归等<br>5.对heatmap进行非极大抑制,找到峰值点作为检测到的目标中心<br>6.在每个目标中心的位置,从回归头结果中提取出坐标、尺寸、旋转等属性,形成3D检测框<br>7.进入两个阶段Refine模块:<br>(1) 从backbone特征图上采样5个点的特征,表示预测3D框的5个表面中心<br>(2) 将采样特征连接,经过MLP生成iou预测和框回归结果<br>(3) 更新检测框结果,形成最终输出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简要介绍激光雷达的原理&lt;/p&gt;
&lt;h2 id=&quot;基本原理&quot;&gt;基本原理&lt;/h2&gt;
&lt;h3 id=&quot;测距原理&quot;&gt;测距原理&lt;/h3&gt;
&lt;p&gt;激光反射，根据飞行时间ToF来计算目标物体的距离。x = ct/2&lt;/p&gt;
&lt;h3 id=&quot;扫描原理&quot;&gt;扫描原理&lt;/h3&gt;
&lt;p&gt;大致分为两</summary>
      
    
    
    
    <category term="hardware" scheme="https://nuclearslippers.github.io/categories/hardware/"/>
    
    
  </entry>
  
</feed>
